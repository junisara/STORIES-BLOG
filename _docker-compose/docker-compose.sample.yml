version: '3.3'

#########################
# 1. docker-compose
# 2. Dockerfile로 빌드후 실행해야함
#    > sudo docker-compose up --build -d
#
# 꼭 설치후 방화벽을 열어줘야만 DB, WP, Adminer가 접근이 가능함
#########################

# 컨테이너 서비스
services:
  # proxy 설정
  wordpress_proxy:
    image: nginx
    ports:
      - 8000:80 # 실제 8000포트로 서비스 됨(default.conf 설정에서 9000포트의 WP(PHP)를 가져와서..)
      - 8443:443
    volumes:
      - ./wordpress_proxy/default.conf:/etc/nginx/conf.d/default.conf
      - ./wordpress_proxy/nginx.conf:/etc/nginx/nginx.conf
      - ./wordpress_proxy_cert:/app/cert
      - ./wordpress:/var/www/html
    restart: always
    depends_on:
      - wordpress
    networks:
      - stories-network

  # wordpress
  wordpress:
    # image: wordpress:6.5.3-php8.3-fpm
    build:
      context: ./_PHP_custom # Dockerfile이 있는 경로
      dockerfile: Dockerfile
    user: '1000'
    environment:
      WORDPRESS_DB_HOST: wordpress_db:3306
      WORDPRESS_DB_USER: wdpress
      WORDPRESS_DB_PASSWORD: wdpresspass
      WORDPRESS_DB_NAME: wordpress_db
    ports:
      - 9000:9000
    volumes:
      - ./wordpress:/var/www/html
    restart: always
    depends_on:
      - wordpress_db
    networks:
      - stories-network

  # db
  wordpress_db:
    image: mysql:8.0
    # cap_add:
    #   - SYS_NICE
    environment:
      MYSQL_DATABASE: wordpress_db
      MYSQL_USER: wdpress
      MYSQL_PASSWORD: wdpresspass
      MYSQL_ROOT_PASSWORD: junisara!1
    ports:
      - '3306:3306'
    volumes:
      - ./wordpress_db:/var/lib/mysql
    restart: always
    networks:
      - stories-network
    # healthcheck:
    #   test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5

  # db 모니터링
  wordpress_adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
    depends_on:
      - wordpress_db
    networks:
      - stories-network

volumes:
  wordpress:
  wordpress_db:
  wordpress_proxy:
  wordpress_proxy_cert:

networks:
  stories-network:
    driver: bridge
#
#
#########################
# 2. proxy/default.conf
#########################

# server {
#     listen 80;
#     server_name eocis.app;

#     location / {
#         rewrite ^ https://$host$request_uri? permanent;
#     }
# }

# server {
#     listen 443 ssl http2;
#     listen [::]:443 ssl http2;
#     server_name eocis.app;

#   root /var/www/html;

#   index index.php;

#   location / {
#     try_files $uri $uri/ /index.php?$args;
#   }

#   rewrite /wp-admin$ $scheme://$host$uri/ permanent;

#   location ~ [^/]\.php(/|$) {
#     fastcgi_split_path_info ^(.+?\.php)(/.*)$;
#     if (!-f $document_root$fastcgi_script_name) {
#       return 404;
#     }

#     include fastcgi_params;
#     fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#     fastcgi_param PATH_INFO       $fastcgi_path_info;
#     fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;

#     fastcgi_pass   blog:9000;
#     fastcgi_index  index.php;
#   }

#     ssl_certificate /app/cert/eocis.app.cer;
#     ssl_certificate_key /app/cert/eocis.app.key;
#     ssl_prefer_server_ciphers on;
#     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
# }

# 코드를 그대로 사용시 server_name, fastcgi_pass, ssl path 정도만 수정하면 되리라.

#########################
# 3. nginx.conf
#########################

# user  nginx;
# worker_processes  auto;

# error_log  /var/log/nginx/error.log notice;
# pid        /var/run/nginx.pid;

# events {
#     worker_connections  1024;
# }

# http {
#     include       /etc/nginx/mime.types;
#     default_type  application/octet-stream;

#     log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
#                       '$status $body_bytes_sent "$http_referer" '
#                       '"$http_user_agent" "$http_x_forwarded_for"';

#     access_log  /var/log/nginx/access.log  main;

#     sendfile        on;
#     #tcp_nopush     on;

#     keepalive_timeout  65;

#     gzip  on;

#     include /etc/nginx/conf.d/*.conf; // <-- 이 부분은 docker-compose의 설정대로 따라가면된다.(default.conf)
# }
